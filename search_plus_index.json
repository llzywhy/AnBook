{"./":{"url":"./","title":"简介","keywords":"","body":"AnBook文档访问链接 AnBook 目的 建立 Android 音视频知识库 定位 Android 音视频，多人协作​ 目标人群 多人协作 撰写 所有文档均使用 Markdown 撰写 原则 表达必须简单易懂，不费脑力 用词必须准确，避免误解 结构清晰简单有逻辑性 整体框架大于关键点远大于细节，且整体和细节必须分开 能用一句话表达的，绝不用两句话 牵扯的东西越少越好，越独立越好 二八原则。用 20% 的知识撬动剩下的 80% 的知识 一个东西往往会有多个视图，多个角度 一个东西往往会有历史，且不完美 红线 避免摆细节 避免不讲逻辑 开发 / 贡献环境 node 环境 gitbook 已很久没有更新，最新的 node 版本并不适配，需要特定的 node 版本。 建议使用 nvm 管理 node 版本。 以下版本测试没有问题, 使用如下的版本即可。 $ node -v v13.14.0 $ npm -v 6.14.14 gitbook 安装 $ npm install -g gitbook-cli $ gitbook --version CLI version: 2.3.2 GitBook version: 3.2.3 仓库下载 $ git clone https://github.com/llzywhy/AnBook.git $ cd AnBook # 进入到仓库根目录中 $ npm install # 安装全部依赖 本地调试 $ cd AnBook # 进入到仓库根目录中 $ npm run serve 一切 OK 即可通过如下链接访问本地文档：http://localhost:4000/ 本地编译 $ cd AnBook # 进入到仓库根目录中 $ npm run build 根目录下的 _book/ 目录即是生成的静态网站文件 修改文档 所有的文档都存放在 doc/ 目录下，并合理分类找到相应的文档位置，打开编辑修改即可 新建文档 修改 SUMMARY.md 文件，在相应合适的位置添加条目然后执行如下命令，即可在相应的位置生成文件 $ npm run init push 修改 修改完并本地调试 OK 之后，即可按照 git 流程 push 相应的修改到 main branch push 到 main 的命令： $ cd AnBook # 进入到仓库根目录中 $ git push origin main github merge 后，会自动触发 workflow, 自动更新文档 创建插件 patch 有时候需要修改插件代码来满足我们的需求，比如修改 gitbook 主题而修改插件代码之后则需要生成一个 patch 来把修改保存下来 创建 patch 的命令： $ cd AnBook # 进入到仓库根目录中 $ npx patch-package gitbook-plugin-theme-lou # gitbook-plugin-theme-lou 是插件名，需要自行修改 生成的 patch 文件存放在仓库根目录的 patches/ 目录中 "},"doc/andriod/Andriod概述.html":{"url":"doc/andriod/Andriod概述.html","title":"Android 概述","keywords":"","body":"Android 概述 Android 源码在线阅读 https://cs.android.com/android/platform/superproject ​​Android 操作系统文档 https://source.android.com/docs Android 应用开发文档 https://developer.android.com/about Android 系统框架 Player ExoPlayer​NuPlayer​MediaPlayerVLC 音视频处理框架/Android 多媒体框架 FFmpegGSteamerOpenMaxCodec2MediaCodecV4L2tinyalsa/alsa 音视频编解码 video H264H265 audio AACOpus 音视频传输协议 WebRTCRTPRTCPHLSHTTPTCPIPRTSPIGMP 投屏协议 DLNAMiracastAirPlay 其他 gitgerritJinkensopengrokRDKYoctobuildrootsystrace​​dumpsysNinja​​bugreport "},"doc/andriod/Android系统架构.html":{"url":"doc/andriod/Android系统架构.html","title":"Android 系统架构","keywords":"","body":"Android 系统架构 本篇文章目标 了解 Android 系统架构 系统架构图 Android 是一种基于 Linux 的开放源代码软件栈，为各类设备和机型而创建。下图所示为 Android 平台的主要组件。 Linux 内核 Android 平台的基础是 Linux 内核。例如，Android Runtime (ART) 依靠 Linux 内核来执行底层功能例如，线程和低层内存管理。 硬件抽象层 (HAL) 硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。 Android Runtime 对于运行 Android 5.0（API 级别 21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的 Android Runtime (ART) 实例。 ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如 Jack）将 Java 源代码编译为 DEX 字节码，使其可在 Android 平台上运行。 ART 的部分主要功能包括： 预先 (AOT) 和即时 (JIT) 编译 优化的垃圾回收 (GC) 在 Android 9（API 级别 28）及更高版本的系统中，支持将应用软件包中的 Dalvik Executable 格式 (DEX) 文件转换为更紧凑的机器代码。 更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置观察点以监控特定字段 在 Android 版本 5.0（API 级别 21）之前，Dalvik 是 Android Runtime。如果您的应用在 ART 上运行效果很好，那么它应该也可在 Dalvik 上运行，但反过来不一定。 Android 还包含一套核心运行时库，可提供 Java API 框架所使用的 Java 编程语言中的大部分功能，包括一些 Java 8 语言功能。 原生 C/C++ 库 许多核心 Android 系统组件和服务（例如 ART 和 HAL）构建自原生代码，需要以 C 和 C++ 编写的原生库。Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。例如，您可以通过 Android 框架的 Java OpenGL API 访问 OpenGL ES，以支持在应用中绘制和操作 2D 和 3D 图形。 如果开发的是需要 C 或 C++ 代码的应用，可以使用 Android NDK 直接从原生代码访问某些原生平台库。 Java API 框架 您可通过以 Java 语言编写的 API 使用 Android OS 的整个功能集。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务： 丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器 资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件 通知管理器，可让所有应用在状态栏中显示自定义提醒 Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈 内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据 开发者可以完全访问 Android 系统应用使用的框架 API。 系统应用 Android 随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。平台随附的应用与用户可以选择安装的应用一样，没有特殊状态。因此第三方应用可成为用户的默认网络浏览器、短信 Messenger 甚至默认键盘（有一些例外，例如系统的“设置”应用）。 系统应用可用作用户的应用，以及提供开发者可从其自己的应用访问的主要功能。例如，如果您的应用要发短信，您无需自己构建该功能，可以改为调用已安装的短信应用向您指定的接收者发送消息。 系统启动架构图 Android 系统启动过程由上图从下往上的一个过程是由 Boot Loader 引导开机，然后依次进入 Kernel -> Native -> Framework -> App "},"doc/andriod/Binder.html":{"url":"doc/andriod/Binder.html","title":"Binder","keywords":"","body":"Binder 本篇文章目标 理解 binder 熟悉 binder 在 Android 的使用 了解 binder 的通信过程 binder 是什么 Binder 是 Android 系统进程间通信​（IPC）方式之一，它是基于开源的 OpenBinder 实现的Android 系统的许多服务都是基于 Binder，所以理解 Binder 对于理解服务的流程有很大的帮助 关键点：进程间通信 实现binder的理由 1. 通信方式 Android 系统有各种复杂的服务，为了应对各种复杂的服务之间的通信，需要实现一种基于Client-Server的通信方式。而现有的消息队列/共享内存/信号量/socket 等IPC都不符合要求。 关键点：Client-Server 2. 传输性能 各种IPC方式数据拷贝次数 IPC 数据拷贝次数 共享内存 0 Binder 1 Socket/管道/消息队列 2 关键点：只拷贝1次 3. 安全性考虑 Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。 Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。 其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。 关键点: 利用 UID 实现安全性 Binder 面向对象的设计思想 Binder使用Client-Server通信方式：一个进程作为Server提供诸如视频/音频解码，视频捕获，地址本查询，网络连接等服务；多个进程作为Client向Server发起服务请求，获得所需要的服务。 要想实现Client-Server通信据必须实现以下两点：一是server必须有确定的访问接入点或者说地址来接受Client的请求，并且Client可以通过某种途径获知Server的地址；二是制定Command-Reply协议来传输数据。例如在网络通信中Server的访问接入点就是Server主机的IP地址+端口号，传输协议为TCP协议。对Binder而言，Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。 与其它IPC不同，Binder使用了面向对象的思想来描述作为访问接入点的Binder及其在Client中的入口：Binder是一个实体位于Server中的对象，该对象提供了一套方法用以实现对服务的请求，就象类的成员函数。 遍布于client中的入口可以看成指向这个binder对象的‘指针’，一旦获得了这个‘指针’就可以调用该对象的方法访问server。在Client看来，通过Binder‘指针’调用其提供的方法和通过指针调用其它任何本地对象的方法并无区别，尽管前者的实体位于远端Server中，而后者实体位于本地内存中。‘指针’是C++的术语，而更通常的说法是引用，即Client通过Binder的引用访问Server。而软件领域另一个术语‘句柄’也可以用来表述Binder在Client中的存在方式。从通信的角度看，Client中的Binder也可以看作是Server Binder的‘代理’，在本地代表远端Server为Client提供服务。本文中会使用‘引用’或‘句柄’这个两广泛使用的术语。 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。 最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。 当然面向对象只是针对应用程序而言，对于Binder驱动和内核其它模块一样使用C语言实现，没有类和对象的概念。Binder驱动为面向对象的进程间通信提供底层支持。 关键点：通过面向对象，把进程间通信转化成本地调用 Binder 架构 Binder框架定义了四个角色：Server，Client，ServiceManager 以及 Binder 驱动。其中 Server，Client，ServiceManager运行于用户空间，Binder 驱动运行于内核空间。 关键点：Server，Client，ServiceManager，Binder驱动 匿名 Binder 并不是所有Binder都需要注册给SMgr广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。 由于这个Binder没有向SMgr注册名字，所以是个匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求 关键点：没有向 ServiceManager 注册名字 Binder CPP 类图 BpBinder: Binder proxy，表示代理，是客户端持有的一个代理对象transact：客户端持有后，BpBinder.transact() 用于发送命令。 BnBinder: Binder native，表示本地对象。与 BBinder 是同一个东西onTransact：本地服务端，BBinder.onTransact() 用于响应命令并处理。 BpRefBase mRemote 指针指向 IBinder，具体是 BpBinder 对象。 参考资料 https://redspider110.github.io/2017/12/21/0041-android-binder/ http://gityuan.com/2015/10/31/binder-prepare/ "},"doc/player/ExoPlayer.html":{"url":"doc/player/ExoPlayer.html","title":"Exoplayer","keywords":"","body":"Exoplayer "},"doc/player/NuPlayer.html":{"url":"doc/player/NuPlayer.html","title":"Nuplayer","keywords":"","body":"Nuplayer "},"doc/player/MediaPlayer.html":{"url":"doc/player/MediaPlayer.html","title":"Medialayer","keywords":"","body":"Medialayer "},"doc/player/VLC.html":{"url":"doc/player/VLC.html","title":"VLC","keywords":"","body":"VLC "},"doc/framework/FFmpeg.html":{"url":"doc/framework/FFmpeg.html","title":"FFmpeg","keywords":"","body":"FFmpeg "},"doc/framework/GSteamer.html":{"url":"doc/framework/GSteamer.html","title":"GSteamer","keywords":"","body":"GSteamer "},"doc/framework/OpenMax.html":{"url":"doc/framework/OpenMax.html","title":"OpenMax","keywords":"","body":"OpenMax "},"doc/framework/Codec2.html":{"url":"doc/framework/Codec2.html","title":"Codec2","keywords":"","body":"Codec2 "},"doc/framework/MediaCodec.html":{"url":"doc/framework/MediaCodec.html","title":"MediaCodec","keywords":"","body":"MediaCodec "},"doc/framework/V4L2.html":{"url":"doc/framework/V4L2.html","title":"V4L2","keywords":"","body":"V4L2 "},"doc/framework/ALSA.html":{"url":"doc/framework/ALSA.html","title":"ALSA","keywords":"","body":"ALSA "},"doc/codec/video/H264.html":{"url":"doc/codec/video/H264.html","title":"H264","keywords":"","body":"H264 "},"doc/codec/video/H265.html":{"url":"doc/codec/video/H265.html","title":"H265","keywords":"","body":"H265 "},"doc/codec/audio/AAC.html":{"url":"doc/codec/audio/AAC.html","title":"AAC","keywords":"","body":"AAC "},"doc/codec/audio/Opus.html":{"url":"doc/codec/audio/Opus.html","title":"Opus","keywords":"","body":"Opus "},"doc/transfer_protocol/WebRTC.html":{"url":"doc/transfer_protocol/WebRTC.html","title":"WebRTC","keywords":"","body":"WebRTC "},"doc/transfer_protocol/RTP.html":{"url":"doc/transfer_protocol/RTP.html","title":"RTP","keywords":"","body":"RTP "},"doc/transfer_protocol/RTCP.html":{"url":"doc/transfer_protocol/RTCP.html","title":"RTCP","keywords":"","body":"RTCP "},"doc/transfer_protocol/HLS.html":{"url":"doc/transfer_protocol/HLS.html","title":"HLS","keywords":"","body":"HLS "},"doc/transfer_protocol/HTTP.html":{"url":"doc/transfer_protocol/HTTP.html","title":"HTTP","keywords":"","body":"HTTP "},"doc/transfer_protocol/TCP.html":{"url":"doc/transfer_protocol/TCP.html","title":"TCP","keywords":"","body":"TCP "},"doc/transfer_protocol/RTSP.html":{"url":"doc/transfer_protocol/RTSP.html","title":"RTSP","keywords":"","body":"RTSP "},"doc/transfer_protocol/IGMP.html":{"url":"doc/transfer_protocol/IGMP.html","title":"IGMP","keywords":"","body":"IGMP "},"doc/cast_screen/DLNA.html":{"url":"doc/cast_screen/DLNA.html","title":"DLNA","keywords":"","body":"DLNA "},"doc/cast_screen/Miracast.html":{"url":"doc/cast_screen/Miracast.html","title":"Miracast","keywords":"","body":"Miracast "},"doc/cast_screen/AirPlay.html":{"url":"doc/cast_screen/AirPlay.html","title":"AirPlay","keywords":"","body":"AirPlay "},"doc/other/Git.html":{"url":"doc/other/Git.html","title":"Git","keywords":"","body":"Git "},"doc/other/Gerrit.html":{"url":"doc/other/Gerrit.html","title":"Gerrit","keywords":"","body":"Gerrit "},"doc/other/Jinken.html":{"url":"doc/other/Jinken.html","title":"Jinkens","keywords":"","body":"Jinkens "},"doc/other/OpenGrok.html":{"url":"doc/other/OpenGrok.html","title":"OpenGrok","keywords":"","body":"OpenGrok "},"doc/other/RDK.html":{"url":"doc/other/RDK.html","title":"RDK","keywords":"","body":"RDK "},"doc/other/Yocto.html":{"url":"doc/other/Yocto.html","title":"Yocto","keywords":"","body":"Yocto "},"doc/other/BuildRoot.html":{"url":"doc/other/BuildRoot.html","title":"BuildRoot","keywords":"","body":"BuildRoot "},"doc/other/SysTrace.html":{"url":"doc/other/SysTrace.html","title":"SysTrace","keywords":"","body":"SysTrace "},"doc/other/DumpSys.html":{"url":"doc/other/DumpSys.html","title":"DumpSys","keywords":"","body":"DumpSys "},"doc/other/Ninja.html":{"url":"doc/other/Ninja.html","title":"Ninja","keywords":"","body":"Ninja "},"doc/other/BugReport.html":{"url":"doc/other/BugReport.html","title":"BugReport","keywords":"","body":"BugReport "}}